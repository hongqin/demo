.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Forest::Tree 3"
.TH Bio::Phylo::Forest::Tree 3 "2010-12-14" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Phylo::Forest::Tree \- Phylogenetic tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\& # some way to get a tree
\& use Bio::Phylo::IO;
\& my $string = '((A,B),C);';
\& my $forest = Bio::Phylo::IO->parse(
\&    -format => 'newick',
\&    -string => $string
\& );
\& my $tree = $forest->first;
.Ve
.PP
.Vb 2
\& # do something:
\& print $tree->calc_imbalance;
.Ve
.PP
.Vb 1
\& # prints "1"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The object models a phylogenetic tree, a container of
Bio::Phylo::Forest::Node objects. The tree object
inherits from Bio::Phylo::Listable, so look there
for more methods.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CONSTRUCTORS\s0"
.IX Subsection "CONSTRUCTORS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Tree constructor.
.Sp
.Vb 6
\& Type    : Constructor
\& Title   : new
\& Usage   : my $tree = Bio::Phylo::Forest::Tree->new;
\& Function: Instantiates a Bio::Phylo::Forest::Tree object.
\& Returns : A Bio::Phylo::Forest::Tree object.
\& Args    : No required arguments.
.Ve
.IP "\fInew_from_bioperl()\fR" 4
.IX Item "new_from_bioperl()"
Tree constructor from Bio::Tree::TreeI argument.
.Sp
.Vb 10
\& Type    : Constructor
\& Title   : new_from_bioperl
\& Usage   : my $tree = 
\&           Bio::Phylo::Forest::Tree->new_from_bioperl(
\&               $bptree           
\&           );
\& Function: Instantiates a 
\&           Bio::Phylo::Forest::Tree object.
\& Returns : A Bio::Phylo::Forest::Tree object.
\& Args    : A tree that implements Bio::Tree::TreeI
.Ve
.Sh "\s-1MUTATORS\s0"
.IX Subsection "MUTATORS"
.IP "\fIset_as_unrooted()\fR" 4
.IX Item "set_as_unrooted()"
Sets tree to be interpreted as unrooted.
.Sp
.Vb 11
\& Type    : Mutator
\& Title   : set_as_unrooted
\& Usage   : $tree->set_as_unrooted;
\& Function: Sets tree to be interpreted as unrooted.
\& Returns : $tree
\& Args    : NONE
\& Comments: This is a flag to indicate that the invocant
\&           is interpreted to be unrooted (regardless of
\&           topology). The object is otherwise unaltered,
\&           this method is only here to capture things such
\&           as the [&U] token in nexus files.
.Ve
.IP "\fIset_as_default()\fR" 4
.IX Item "set_as_default()"
Sets tree to be the default tree in a forest
.Sp
.Vb 9
\& Type    : Mutator
\& Title   : set_as_default
\& Usage   : $tree->set_as_default;
\& Function: Sets tree to be default tree in forest
\& Returns : $tree
\& Args    : NONE
\& Comments: This is a flag to indicate that the invocant
\&           is the default tree in a forest, i.e. to
\&           capture the '*' token in nexus files.
.Ve
.IP "\fIset_not_default()\fR" 4
.IX Item "set_not_default()"
Sets tree to \s-1NOT\s0 be the default tree in a forest
.Sp
.Vb 9
\& Type    : Mutator
\& Title   : set_not_default
\& Usage   : $tree->set_not_default;
\& Function: Sets tree to not be default tree in forest
\& Returns : $tree
\& Args    : NONE
\& Comments: This is a flag to indicate that the invocant
\&           is the default tree in a forest, i.e. to
\&           capture the '*' token in nexus files.
.Ve
.Sh "\s-1QUERIES\s0"
.IX Subsection "QUERIES"
.IP "\fIget_midpoint()\fR" 4
.IX Item "get_midpoint()"
Gets node that divides tree into two distance-balanced partitions.
.Sp
.Vb 7
\& Type    : Query
\& Title   : get_midpoint
\& Usage   : my $midpoint = $tree->get_midpoint;
\& Function: Gets node nearest to the middle of the longest path
\& Returns : A Bio::Phylo::Forest::Node object.
\& Args    : NONE
\& Comments: This algorithm was ported from ETE
.Ve
.IP "\fIget_terminals()\fR" 4
.IX Item "get_terminals()"
Get terminal nodes.
.Sp
.Vb 14
\& Type    : Query
\& Title   : get_terminals
\& Usage   : my @terminals = @{ $tree->get_terminals };
\& Function: Retrieves all terminal nodes in
\&           the Bio::Phylo::Forest::Tree object.
\& Returns : An array reference of 
\&           Bio::Phylo::Forest::Node objects.
\& Args    : NONE
\& Comments: If the tree is valid, this method 
\&           retrieves the same set of nodes as 
\&           $node->get_terminals($root). However, 
\&           because there is no recursion it may 
\&           be faster. Also, the node method by 
\&           the same name does not see orphans.
.Ve
.IP "\fIget_internals()\fR" 4
.IX Item "get_internals()"
Get internal nodes.
.Sp
.Vb 14
\& Type    : Query
\& Title   : get_internals
\& Usage   : my @internals = @{ $tree->get_internals };
\& Function: Retrieves all internal nodes 
\&           in the Bio::Phylo::Forest::Tree object.
\& Returns : An array reference of 
\&           Bio::Phylo::Forest::Node objects.
\& Args    : NONE
\& Comments: If the tree is valid, this method 
\&           retrieves the same set of nodes as 
\&           $node->get_internals($root). However, 
\&           because there is no recursion it may 
\&           be faster. Also, the node method by 
\&           the same name does not see orphans.
.Ve
.IP "\fIget_root()\fR" 4
.IX Item "get_root()"
Get root node.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_root
\& Usage   : my $root = $tree->get_root;
\& Function: Retrieves the first orphan in 
\&           the current Bio::Phylo::Forest::Tree
\&           object - which should be the root.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_tallest_tip()\fR" 4
.IX Item "get_tallest_tip()"
Retrieves the node furthest from the root. 
.Sp
.Vb 11
\& Type    : Query
\& Title   : get_tallest_tip
\& Usage   : my $tip = $tree->get_tallest_tip;
\& Function: Retrieves the node furthest from the
\&           root in the current Bio::Phylo::Forest::Tree
\&           object.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
\& Comments: If the tree has branch lengths, the tallest tip is
\&           based on root-to-tip path length, else it is based
\&           on number of nodes to root
.Ve
.IP "\fIget_nodes_for_taxa()\fR" 4
.IX Item "get_nodes_for_taxa()"
Gets node objects for the supplied taxon objects
.Sp
.Vb 7
\& Type    : Query
\& Title   : get_nodes_for_taxa
\& Usage   : my @nodes = @{ $tree->get_nodes_for_taxa(\e@taxa) };
\& Function: Gets node objects for the supplied taxon objects
\& Returns : array ref of Bio::Phylo::Forest::Node objects
\& Args    : A reference to an array of Bio::Phylo::Taxa::Taxon objects
\&           or a Bio::Phylo::Taxa object
.Ve
.IP "\fIget_mrca()\fR" 4
.IX Item "get_mrca()"
Get most recent common ancestor of argument nodes.
.Sp
.Vb 9
\& Type    : Query
\& Title   : get_mrca
\& Usage   : my $mrca = $tree->get_mrca(\e@nodes);
\& Function: Retrieves the most recent 
\&           common ancestor of \e@nodes
\& Returns : Bio::Phylo::Forest::Node
\& Args    : A reference to an array of 
\&           Bio::Phylo::Forest::Node objects 
\&           in $tree.
.Ve
.Sh "\s-1TESTS\s0"
.IX Subsection "TESTS"
.IP "\fIis_default()\fR" 4
.IX Item "is_default()"
Test if tree is default tree.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_default
\& Usage   : if ( $tree->is_default ) {
\&              # do something
\&           }
\& Function: Tests whether the invocant 
\&           object is the default tree in the forest.
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_rooted()\fR" 4
.IX Item "is_rooted()"
Test if tree is rooted.
.Sp
.Vb 12
\& Type    : Test
\& Title   : is_rooted
\& Usage   : if ( $tree->is_rooted ) {
\&              # do something
\&           }
\& Function: Tests whether the invocant 
\&           object is rooted.
\& Returns : BOOLEAN
\& Args    : NONE
\& Comments: A tree is considered unrooted if:
\&           - set_as_unrooted has been set, or
\&           - the basal split is a polytomy
.Ve
.IP "\fIis_binary()\fR" 4
.IX Item "is_binary()"
Test if tree is bifurcating.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_binary
\& Usage   : if ( $tree->is_binary ) {
\&              # do something
\&           }
\& Function: Tests whether the invocant 
\&           object is bifurcating.
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_ultrametric()\fR" 4
.IX Item "is_ultrametric()"
Test if tree is ultrametric.
.Sp
.Vb 21
\& Type    : Test
\& Title   : is_ultrametric
\& Usage   : if ( $tree->is_ultrametric(0.01) ) {
\&              # do something
\&           }
\& Function: Tests whether the invocant is 
\&           ultrametric.
\& Returns : BOOLEAN
\& Args    : Optional margin between pairwise 
\&           comparisons (default = 0).
\& Comments: The test is done by performing 
\&           all pairwise comparisons for
\&           root-to-tip path lengths. Since many 
\&           programs introduce rounding errors 
\&           in branch lengths the optional argument is
\&           available to test TRUE for nearly 
\&           ultrametric trees. For example, a value 
\&           of 0.01 indicates that no pairwise
\&           comparison may differ by more than 1%. 
\&           Note: behaviour is undefined for 
\&           negative branch lengths.
.Ve
.IP "\fIis_monophyletic()\fR" 4
.IX Item "is_monophyletic()"
Tests if first argument (node array ref) is monophyletic with respect
to second argument.
.Sp
.Vb 12
\& Type    : Test
\& Title   : is_monophyletic
\& Usage   : if ( $tree->is_monophyletic(\e@tips, $node) ) {
\&              # do something
\&           }
\& Function: Tests whether the set of \e@tips is
\&           monophyletic w.r.t. $outgroup.
\& Returns : BOOLEAN
\& Args    : A reference to a list of nodes, and a node.
\& Comments: This method is essentially the
\&           same as 
\&           &Bio::Phylo::Forest::Node::is_outgroup_of.
.Ve
.IP "\fIis_paraphyletic()\fR" 4
.IX Item "is_paraphyletic()"
.Vb 10
\& Type    : Test
\& Title   : is_paraphyletic
\& Usage   : if ( $tree->is_paraphyletic(\e@nodes,$node) ){ }
\& Function: Tests whether or not a given set of nodes are paraphyletic
\&           (representing the full clade) given an outgroup
\& Returns : [-1,0,1] , -1 if the group is not monophyletic
\&                       0 if the group is not paraphyletic
\&                       1 if the group is paraphyletic
\& Args    : Array ref of node objects which are in the tree,
\&           Outgroup to compare the nodes to
.Ve
.IP "\fIis_clade()\fR" 4
.IX Item "is_clade()"
Tests if argument (node array ref) forms a clade.
.Sp
.Vb 12
\& Type    : Test
\& Title   : is_clade
\& Usage   : if ( $tree->is_clade(\e@tips) ) {
\&              # do something
\&           }
\& Function: Tests whether the set of 
\&           \e@tips forms a clade
\& Returns : BOOLEAN
\& Args    : A reference to an array of Bio::Phylo::Forest::Node objects, or a
\&           reference to an array of Bio::Phylo::Taxa::Taxon objects, or a
\&           Bio::Phylo::Taxa object
\& Comments:
.Ve
.IP "\fIis_cladogram()\fR" 4
.IX Item "is_cladogram()"
Tests if tree is a cladogram (i.e. no branch lengths)
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_cladogram
\& Usage   : if ( $tree->is_cladogram() ) {
\&              # do something
\&           }
\& Function: Tests whether the tree is a 
\&           cladogram (i.e. no branch lengths)
\& Returns : BOOLEAN
\& Args    : NONE
\& Comments:
.Ve
.Sh "\s-1CALCULATIONS\s0"
.IX Subsection "CALCULATIONS"
.IP "\fIcalc_branch_length_distance()\fR" 4
.IX Item "calc_branch_length_distance()"
Calculates the Euclidean branch length distance between two trees.
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_branch_length_distance
\& Usage   : my $distance = 
\&           $tree1->calc_branch_length_distance($tree2);
\& Function: Calculates the Euclidean branch length distance between two trees
\& Returns : SCALAR, number
\& Args    : NONE
.Ve
.IP "\fIcalc_branch_length_score()\fR" 4
.IX Item "calc_branch_length_score()"
Calculates the squared Euclidean branch length distance between two trees.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_branch_length_score
\& Usage   : my $score = 
\&           $tree1->calc_branch_length_score($tree2);
\& Function: Calculates the squared Euclidean branch
\&           length distance between two trees
\& Returns : SCALAR, number
\& Args    : NONE
.Ve
.IP "\fIcalc_tree_length()\fR" 4
.IX Item "calc_tree_length()"
Calculates the sum of all branch lengths.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_tree_length
\& Usage   : my $tree_length = 
\&           $tree->calc_tree_length;
\& Function: Calculates the sum of all branch 
\&           lengths (i.e. the tree length).
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_tree_height()\fR" 4
.IX Item "calc_tree_height()"
Calculates the height of the tree.
.Sp
.Vb 15
\& Type    : Calculation
\& Title   : calc_tree_height
\& Usage   : my $tree_height = 
\&           $tree->calc_tree_height;
\& Function: Calculates the height 
\&           of the tree.
\& Returns : FLOAT
\& Args    : NONE
\& Comments: For ultrametric trees this 
\&           method returns the height, but 
\&           this is done by averaging over 
\&           all root-to-tip path lengths, so 
\&           for additive trees the result 
\&           should consequently be interpreted
\&           differently.
.Ve
.IP "\fIcalc_number_of_nodes()\fR" 4
.IX Item "calc_number_of_nodes()"
Calculates the number of nodes.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_number_of_nodes
\& Usage   : my $number_of_nodes = 
\&           $tree->calc_number_of_nodes;
\& Function: Calculates the number of 
\&           nodes (internals AND terminals).
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_number_of_terminals()\fR" 4
.IX Item "calc_number_of_terminals()"
Calculates the number of terminal nodes.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_number_of_terminals
\& Usage   : my $number_of_terminals = 
\&           $tree->calc_number_of_terminals;
\& Function: Calculates the number 
\&           of terminal nodes.
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_number_of_internals()\fR" 4
.IX Item "calc_number_of_internals()"
Calculates the number of internal nodes.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_number_of_internals
\& Usage   : my $number_of_internals = 
\&           $tree->calc_number_of_internals;
\& Function: Calculates the number 
\&           of internal nodes.
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_number_of_cherries()\fR" 4
.IX Item "calc_number_of_cherries()"
Calculates the number of cherries, i.e. the number of nodes that subtend
exactly two tips. See for applications of this metric:
<http://dx.doi.org/10.1016/S0025\-5564(99)00060\-7>
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_number_of_cherries
\& Usage   : my $number_of_cherries = 
\&           $tree->calc_number_of_cherries;
\& Function: Calculates the number of cherries
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_total_paths()\fR" 4
.IX Item "calc_total_paths()"
Calculates the sum of all root-to-tip path lengths.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_total_paths
\& Usage   : my $total_paths = 
\&           $tree->calc_total_paths;
\& Function: Calculates the sum of all 
\&           root-to-tip path lengths.
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_redundancy()\fR" 4
.IX Item "calc_redundancy()"
Calculates the amount of shared (redundant) history on the total.
.Sp
.Vb 10
\& Type    : Calculation
\& Title   : calc_redundancy
\& Usage   : my $redundancy = 
\&           $tree->calc_redundancy;
\& Function: Calculates the amount of shared 
\&           (redundant) history on the total.
\& Returns : FLOAT
\& Args    : NONE
\& Comments: Redundancy is calculated as
\& 1 / ( treelength - height / ( ntax * height - height ) )
.Ve
.IP "\fIcalc_imbalance()\fR" 4
.IX Item "calc_imbalance()"
Calculates Colless' coefficient of tree imbalance.
.Sp
.Vb 10
\& Type    : Calculation
\& Title   : calc_imbalance
\& Usage   : my $imbalance = $tree->calc_imbalance;
\& Function: Calculates Colless' coefficient 
\&           of tree imbalance.
\& Returns : FLOAT
\& Args    : NONE
\& Comments: As described in Colless, D.H., 1982. 
\&           The theory and practice of phylogenetic 
\&           systematics. Systematic Zoology 31(1): 100-104
.Ve
.IP "\fIcalc_i2()\fR" 4
.IX Item "calc_i2()"
Calculates I2 imbalance.
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_i2
\& Usage   : my $ci2 = $tree->calc_i2;
\& Function: Calculates I2 imbalance.
\& Returns : FLOAT
\& Args    : NONE
\& Comments:
.Ve
.IP "\fIcalc_gamma()\fR" 4
.IX Item "calc_gamma()"
Calculates the Pybus gamma statistic.
.Sp
.Vb 11
\& Type    : Calculation
\& Title   : calc_gamma
\& Usage   : my $gamma = $tree->calc_gamma();
\& Function: Calculates the Pybus gamma statistic
\& Returns : FLOAT
\& Args    : NONE
\& Comments: As described in Pybus, O.G. and 
\&           Harvey, P.H., 2000. Testing
\&           macro-evolutionary models using 
\&           incomplete molecular phylogenies. 
\&           Proc. R. Soc. Lond. B 267, 2267-2272
.Ve
.IP "\fIcalc_fiala_stemminess()\fR" 4
.IX Item "calc_fiala_stemminess()"
Calculates stemminess measure of Fiala and Sokal (1985).
.Sp
.Vb 14
\& Type    : Calculation
\& Title   : calc_fiala_stemminess
\& Usage   : my $fiala_stemminess = 
\&           $tree->calc_fiala_stemminess;
\& Function: Calculates stemminess measure 
\&           Fiala and Sokal (1985).
\& Returns : FLOAT
\& Args    : NONE
\& Comments: As described in Fiala, K.L. and 
\&           R.R. Sokal, 1985. Factors 
\&           determining the accuracy of 
\&           cladogram estimation: evaluation 
\&           using computer simulation. 
\&           Evolution, 39: 609-622
.Ve
.IP "\fIcalc_rohlf_stemminess()\fR" 4
.IX Item "calc_rohlf_stemminess()"
Calculates stemminess measure from Rohlf et al. (1990).
.Sp
.Vb 14
\& Type    : Calculation
\& Title   : calc_rohlf_stemminess
\& Usage   : my $rohlf_stemminess = 
\&           $tree->calc_rohlf_stemminess;
\& Function: Calculates stemminess measure 
\&           from Rohlf et al. (1990).
\& Returns : FLOAT
\& Args    : NONE
\& Comments: As described in Rohlf, F.J., 
\&           W.S. Chang, R.R. Sokal, J. Kim, 
\&           1990. Accuracy of estimated 
\&           phylogenies: effects of tree 
\&           topology and evolutionary model. 
\&           Evolution, 44(6): 1671-1684
.Ve
.IP "\fIcalc_resolution()\fR" 4
.IX Item "calc_resolution()"
Calculates tree resolution.
.Sp
.Vb 11
\& Type    : Calculation
\& Title   : calc_resolution
\& Usage   : my $resolution = 
\&           $tree->calc_resolution;
\& Function: Calculates the number 
\&           of internal nodes over the
\&           total number of internal nodes 
\&           on a fully bifurcating
\&           tree of the same size.
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_branching_times()\fR" 4
.IX Item "calc_branching_times()"
Calculates cumulative branching times.
.Sp
.Vb 15
\& Type    : Calculation
\& Title   : calc_branching_times
\& Usage   : my $branching_times = 
\&           $tree->calc_branching_times;
\& Function: Returns a two-dimensional array. 
\&           The first dimension consists of 
\&           the "records", so that in the 
\&           second dimension $AoA[$first][0] 
\&           contains the internal node references, 
\&           and $AoA[$first][1] the branching 
\&           time of the internal node. The 
\&           records are orderered from root to 
\&           tips by time from the origin.
\& Returns : SCALAR[][] or FALSE
\& Args    : NONE
.Ve
.IP "\fIcalc_waiting_times()\fR" 4
.IX Item "calc_waiting_times()"
Calculates intervals between splits.
.Sp
.Vb 15
\& Type    : Calculation
\& Title   : calc_waiting_times
\& Usage   : my $waitings = 
\&           $tree->calc_waiting_times;
\& Function: Returns a two-dimensional array. 
\&           The first dimension consists of 
\&           the "records", so that in the 
\&           second dimension $AoA[$first][0] 
\&           contains the internal node references, 
\&           and $AoA[$first][1] the waiting 
\&           time of the internal node. The 
\&           records are orderered from root to 
\&           tips by time from the origin.
\& Returns : SCALAR[][] or FALSE
\& Args    : NONE
.Ve
.IP "\fIcalc_node_ages()\fR" 4
.IX Item "calc_node_ages()"
Calculates node ages.
.Sp
.Vb 13
\& Type    : Calculation
\& Title   : calc_node_ages
\& Usage   : $tree->calc_node_ages;
\& Function: Calculates the age of all the nodes in the tree (i.e. the distance
\&           from the tips) and assigns these to the 'age' slot, such that,
\&           after calling this method, the age of any one node can be retrieved
\&           by calling $node->get_generic('age');
\& Returns : The invocant
\& Args    : NONE
\& Comments: This method computes, in a sense, the opposite of
\&           calc_branching_times: here, we compute the distance from the tips
\&           (i.e. how long ago the split occurred), whereas calc_branching_times
\&           calculates the distance from the root.
.Ve
.IP "\fIcalc_ltt()\fR" 4
.IX Item "calc_ltt()"
Calculates lineage-through-time data points.
.Sp
.Vb 15
\& Type    : Calculation
\& Title   : calc_ltt
\& Usage   : my $ltt = $tree->calc_ltt;
\& Function: Returns a two-dimensional array. 
\&           The first dimension consists of the 
\&           "records", so that in the second 
\&           dimension $AoA[$first][0] contains 
\&           the internal node references, and
\&           $AoA[$first][1] the branching time 
\&           of the internal node, and $AoA[$first][2] 
\&           the cumulative number of lineages over
\&           time. The records are orderered from 
\&           root to tips by time from the origin.
\& Returns : SCALAR[][] or FALSE
\& Args    : NONE
.Ve
.IP "\fIcalc_symdiff()\fR" 4
.IX Item "calc_symdiff()"
Calculates the symmetric difference metric between invocant and argument.
.Sp
.Vb 12
\& Type    : Calculation
\& Title   : calc_symdiff
\& Usage   : my $symdiff = 
\&           $tree->calc_symdiff($other_tree);
\& Function: Returns the symmetric difference 
\&           metric between $tree and $other_tree, 
\&           sensu Penny and Hendy, 1985.
\& Returns : SCALAR
\& Args    : A Bio::Phylo::Forest::Tree object
\& Comments: Trees in comparison must span 
\&           the same set of terminal taxa
\&           or results are meaningless.
.Ve
.IP "\fIcalc_fp()\fR" 4
.IX Item "calc_fp()"
Calculates the Fair Proportion value for each terminal.
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_fp
\& Usage   : my $fp = $tree->calc_fp();
\& Function: Returns the Fair Proportion 
\&           value for each terminal
\& Returns : HASHREF
\& Args    : NONE
.Ve
.IP "\fIcalc_es()\fR" 4
.IX Item "calc_es()"
Calculates the Equal Splits value for each terminal
.Sp
.Vb 6
\& Type    : Calculation
\& Title   : calc_es
\& Usage   : my $es = $tree->calc_es();
\& Function: Returns the Equal Splits value for each terminal
\& Returns : HASHREF
\& Args    : NONE
.Ve
.IP "\fIcalc_pe()\fR" 4
.IX Item "calc_pe()"
Calculates the Pendant Edge value for each terminal.
.Sp
.Vb 6
\& Type    : Calculation
\& Title   : calc_pe
\& Usage   : my $es = $tree->calc_pe();
\& Function: Returns the Pendant Edge value for each terminal
\& Returns : HASHREF
\& Args    : NONE
.Ve
.IP "\fIcalc_shapley()\fR" 4
.IX Item "calc_shapley()"
Calculates the Shapley value for each terminal.
.Sp
.Vb 6
\& Type    : Calculation
\& Title   : calc_shapley
\& Usage   : my $es = $tree->calc_shapley();
\& Function: Returns the Shapley value for each terminal
\& Returns : HASHREF
\& Args    : NONE
.Ve
.Sh "\s-1VISITOR\s0 \s-1METHODS\s0"
.IX Subsection "VISITOR METHODS"
The following methods are a \- not entirely true-to-form \- implementation of the Visitor
design pattern: the nodes in a tree are visited, and rather than having an object
operate on them, a set of code references is used. This can be used, for example, to
serialize a tree to a string format. To create a newick string without branch lengths
you would use something like this (there is a more powerful 'to_newick' method, so this
is just an example):
.PP
.Vb 7
\& $tree->visit_depth_first(
\&        '-pre_daughter'   => sub { print '('             },     
\&        '-post_daughter'  => sub { print ')'             },     
\&        '-in'             => sub { print shift->get_name },
\&        '-pre_sister'     => sub { print ','             },     
\& );
\& print ';';
.Ve
.IP "\fIvisit_depth_first()\fR" 4
.IX Item "visit_depth_first()"
Visits nodes depth first
.Sp
.Vb 6
\& Type    : Visitor method
\& Title   : visit_depth_first
\& Usage   : $tree->visit_depth_first( -pre => sub{ ... }, -post => sub { ... } );
\& Function: Visits nodes in a depth first traversal, executes subs
\& Returns : $tree
\&  Args    : Optional handlers in the order in which they would be executed on an internal node:
.Ve
.Sp
.Vb 2
\&                        # first event handler, is executed when node is reached in recursion
\&                        -pre            => sub { print "pre: ",            shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a daughter, but before that daughter is processed
\&                        -pre_daughter   => sub { print "pre_daughter: ",   shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a daughter, after daughter has been processed 
\&                        -post_daughter  => sub { print "post_daughter: ",  shift->get_name, "\en" },
.Ve
.Sp
.Vb 3
\&                        # is executed whether or not node has sisters, if it does have sisters
\&                        # they're processed first       
\&                        -in             => sub { print "in: ",             shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a sister, before sister is processed
\&                        -pre_sister     => sub { print "pre_sister: ",     shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a sister, after sister is processed
\&                        -post_sister    => sub { print "post_sister: ",    shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed last                      
\&                        -post           => sub { print "post: ",           shift->get_name, "\en" },
.Ve
.Sp
.Vb 4
\&                        # specifies traversal order, default 'ltr' means first_daugher -> next_sister
\&                        # traversal, alternate value 'rtl' means last_daughter -> previous_sister traversal
\&                        -order          => 'ltr', # ltr = left-to-right, 'rtl' = right-to-left
\& Comments:
.Ve
.IP "\fIvisit_breadth_first()\fR" 4
.IX Item "visit_breadth_first()"
Visits nodes breadth first
.Sp
.Vb 6
\& Type    : Visitor method
\& Title   : visit_breadth_first
\& Usage   : $tree->visit_breadth_first( -pre => sub{ ... }, -post => sub { ... } );
\& Function: Visits nodes in a breadth first traversal, executes handlers
\& Returns : $tree
\& Args    : Optional handlers in the order in which they would be executed on an internal node:
.Ve
.Sp
.Vb 2
\&                        # first event handler, is executed when node is reached in recursion
\&                        -pre            => sub { print "pre: ",            shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a sister, before sister is processed
\&                        -pre_sister     => sub { print "pre_sister: ",     shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a sister, after sister is processed
\&                        -post_sister    => sub { print "post_sister: ",    shift->get_name, "\en" },
.Ve
.Sp
.Vb 3
\&                        # is executed whether or not node has sisters, if it does have sisters
\&                        # they're processed first       
\&                        -in             => sub { print "in: ",             shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a daughter, but before that daughter is processed
\&                        -pre_daughter   => sub { print "pre_daughter: ",   shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed if node has a daughter, after daughter has been processed 
\&                        -post_daughter  => sub { print "post_daughter: ",  shift->get_name, "\en" },
.Ve
.Sp
.Vb 2
\&                        # is executed last                      
\&                        -post           => sub { print "post: ",           shift->get_name, "\en" },
.Ve
.Sp
.Vb 4
\&                        # specifies traversal order, default 'ltr' means first_daugher -> next_sister
\&                        # traversal, alternate value 'rtl' means last_daughter -> previous_sister traversal
\&                        -order          => 'ltr', # ltr = left-to-right, 'rtl' = right-to-left
\& Comments:
.Ve
.IP "\fIvisit_level_order()\fR" 4
.IX Item "visit_level_order()"
Visits nodes in a level order traversal.
.Sp
.Vb 7
\& Type    : Visitor method
\& Title   : visit_level_order
\& Usage   : $tree->visit_level_order( sub{...} );
\& Function: Visits nodes in a level order traversal, executes sub
\& Returns : $tree
\& Args    : A subroutine reference that operates on visited nodes.
\& Comments:
.Ve
.Sh "\s-1TREE\s0 \s-1MANIPULATION\s0"
.IX Subsection "TREE MANIPULATION"
.IP "\fIchronompl()\fR" 4
.IX Item "chronompl()"
Modifies branch lengths using the mean path lengths method of
Britton et al. (2002). For more about this method, see:
<http://dx.doi.org/10.1016/S1055\-7903(02)00268\-3>
.Sp
.Vb 7
\& Type    : Tree manipulator
\& Title   : chronompl
\& Usage   : $tree->chronompl;
\& Function: Makes tree ultrametric using MPL method
\& Returns : The modified, now ultrametric invocant.
\& Args    : NONE
\& Comments:
.Ve
.IP "\fIgrafenbl()\fR" 4
.IX Item "grafenbl()"
Computes and assigns branch lengths using Grafen's method, which makes
node ages proportional to clade size. For more about this method, see:
<http://dx.doi.org/10.1098/rstb.1989.0106>
.Sp
.Vb 7
\& Type    : Tree manipulator
\& Title   : grafenbl
\& Usage   : $tree->grafenbl;
\& Function: Assigns branch lengths using Grafen's method
\& Returns : The modified, now ultrametric invocant.
\& Args    : Optional, a power ('rho') to which all node ages are raised
\& Comments:
.Ve
.IP "\fIagetobl()\fR" 4
.IX Item "agetobl()"
Converts node ages to branch lengths
.Sp
.Vb 9
\& Type    : Tree manipulator
\& Title   : agetobl
\& Usage   : $tree->agetobl;
\& Function: Converts node ages to branch lengths
\& Returns : The modified invocant.
\& Args    : NONE
\& Comments: This method uses ages as assigned to the generic 'age' slot
\&           on the nodes in the trees. I.e. for each node in the tree,
\&           $node->get_generic('age') must return a number
.Ve
.IP "\fIultrametricize()\fR" 4
.IX Item "ultrametricize()"
Sets all root-to-tip path lengths equal.
.Sp
.Vb 14
\& Type    : Tree manipulator
\& Title   : ultrametricize
\& Usage   : $tree->ultrametricize;
\& Function: Sets all root-to-tip path 
\&           lengths equal by stretching
\&           all terminal branches to the 
\&           height of the tallest node.
\& Returns : The modified invocant.
\& Args    : NONE
\& Comments: This method is analogous to 
\&           the 'ultrametricize' command
\&           in Mesquite, i.e. no rate smoothing 
\&           or anything like that happens, just 
\&           a lengthening of terminal branches.
.Ve
.IP "\fIscale()\fR" 4
.IX Item "scale()"
Scales the tree to the specified height.
.Sp
.Vb 14
\& Type    : Tree manipulator
\& Title   : scale
\& Usage   : $tree->scale($height);
\& Function: Scales the tree to the 
\&           specified height.
\& Returns : The modified invocant.
\& Args    : $height = a numerical value 
\&           indicating root-to-tip path length.
\& Comments: This method uses the 
\&           $tree->calc_tree_height method, and 
\&           so for additive trees the *average* 
\&           root-to-tip path length is scaled to
\&           $height (i.e. some nodes might be 
\&           taller than $height, others shorter).
.Ve
.IP "\fIresolve()\fR" 4
.IX Item "resolve()"
Randomly breaks polytomies.
.Sp
.Vb 8
\& Type    : Tree manipulator
\& Title   : resolve
\& Usage   : $tree->resolve;
\& Function: Randomly breaks polytomies by inserting 
\&           additional internal nodes.
\& Returns : The modified invocant.
\& Args    :
\& Comments:
.Ve
.IP "\fIprune_tips()\fR" 4
.IX Item "prune_tips()"
Prunes argument nodes from invocant.
.Sp
.Vb 7
\& Type    : Tree manipulator
\& Title   : prune_tips
\& Usage   : $tree->prune_tips(\e@taxa);
\& Function: Prunes specified taxa from invocant.
\& Returns : A pruned Bio::Phylo::Forest::Tree object.
\& Args    : A reference to an array of taxon names.
\& Comments:
.Ve
.IP "\fIkeep_tips()\fR" 4
.IX Item "keep_tips()"
Keeps argument nodes from invocant (i.e. prunes all others).
.Sp
.Vb 7
\& Type    : Tree manipulator
\& Title   : keep_tips
\& Usage   : $tree->keep_tips(\e@taxa);
\& Function: Keeps specified taxa from invocant.
\& Returns : The pruned Bio::Phylo::Forest::Tree object.
\& Args    : An array ref of taxon names or a Bio::Phylo::Taxa object
\& Comments:
.Ve
.IP "\fInegative_to_zero()\fR" 4
.IX Item "negative_to_zero()"
Converts negative branch lengths to zero.
.Sp
.Vb 8
\& Type    : Tree manipulator
\& Title   : negative_to_zero
\& Usage   : $tree->negative_to_zero;
\& Function: Converts negative branch 
\&           lengths to zero.
\& Returns : The modified invocant.
\& Args    : NONE
\& Comments:
.Ve
.IP "\fIladderize()\fR" 4
.IX Item "ladderize()"
Sorts nodes in ascending (or descending) order of number of children.
.Sp
.Vb 6
\& Type    : Tree manipulator
\& Title   : ladderize
\& Usage   : $tree->ladderize(1);
\& Function: Sorts nodes
\& Returns : The modified invocant.
\& Args    : Optional, a true value to reverse the sort order
.Ve
.IP "\fIexponentiate()\fR" 4
.IX Item "exponentiate()"
Raises branch lengths to argument.
.Sp
.Vb 6
\& Type    : Tree manipulator
\& Title   : exponentiate
\& Usage   : $tree->exponentiate($power);
\& Function: Raises branch lengths to $power.
\& Returns : The modified invocant.
\& Args    : A $power in any of perl's number formats.
.Ve
.IP "\fIlog_transform()\fR" 4
.IX Item "log_transform()"
Log argument base transform branch lengths.
.Sp
.Vb 6
\& Type    : Tree manipulator
\& Title   : log_transform
\& Usage   : $tree->log_transform($base);
\& Function: Log $base transforms branch lengths.
\& Returns : The modified invocant.
\& Args    : A $base in any of perl's number formats.
.Ve
.IP "\fIremove_unbranched_internals()\fR" 4
.IX Item "remove_unbranched_internals()"
Collapses internal nodes with fewer than 2 children.
.Sp
.Vb 8
\& Type    : Tree manipulator
\& Title   : remove_unbranched_internals
\& Usage   : $tree->remove_unbranched_internals;
\& Function: Collapses internal nodes 
\&           with fewer than 2 children.
\& Returns : The modified invocant.
\& Args    : NONE
\& Comments:
.Ve
.Sh "\s-1UTILITY\s0 \s-1METHODS\s0"
.IX Subsection "UTILITY METHODS"
.IP "\fIclone()\fR" 4
.IX Item "clone()"
Clones invocant.
.Sp
.Vb 7
\& Type    : Utility method
\& Title   : clone
\& Usage   : my $clone = $object->clone;
\& Function: Creates a copy of the invocant object.
\& Returns : A copy of the invocant.
\& Args    : Optional: a hash of code references to 
\&           override reflection-based getter/setter copying
.Ve
.Sp
.Vb 13
\&           my $clone = $object->clone(  
\&               'set_forest' => sub {
\&                   my ( $self, $clone ) = @_;
\&                   for my $forest ( @{ $self->get_forests } ) {
\&                       $clone->set_forest( $forest );
\&                   }
\&               },
\&               'set_matrix' => sub {
\&                   my ( $self, $clone ) = @_;
\&                   for my $matrix ( @{ $self->get_matrices } ) {
\&                       $clone->set_matrix( $matrix );
\&                   }
\&           );
.Ve
.Sp
.Vb 12
\& Comments: Cloning is currently experimental, use with caution.
\&           It works on the assumption that the output of get_foo
\&           called on the invocant is to be provided as argument
\&           to set_foo on the clone - such as 
\&           $clone->set_name( $self->get_name ). Sometimes this 
\&           doesn't work, for example where this symmetry doesn't
\&           exist, or where the return value of get_foo isn't valid
\&           input for set_foo. If such a copy fails, a warning is 
\&           emitted. To make sure all relevant attributes are copied
\&           into the clone, additional code references can be 
\&           provided, as in the example above. Typically, this is
\&           done by overrides of this method in child classes.
.Ve
.Sh "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\fIto_nexus()\fR" 4
.IX Item "to_nexus()"
Serializes invocant to nexus string.
.Sp
.Vb 7
\& Type    : Stringifier
\& Title   : to_nexus
\& Usage   : my $string = $tree->to_nexus;
\& Function: Turns the invocant tree object 
\&           into a nexus string
\& Returns : SCALAR
\& Args    : Any arguments that can be passed to Bio::Phylo::Forest::to_nexus
.Ve
.IP "\fIto_newick()\fR" 4
.IX Item "to_newick()"
Serializes invocant to newick string.
.Sp
.Vb 7
\& Type    : Stringifier
\& Title   : to_newick
\& Usage   : my $string = $tree->to_newick;
\& Function: Turns the invocant tree object 
\&           into a newick string
\& Returns : SCALAR
\& Args    : NONE
.Ve
.IP "\fIto_xml()\fR" 4
.IX Item "to_xml()"
Serializes invocant to xml.
.Sp
.Vb 6
\& Type    : Serializer
\& Title   : to_xml
\& Usage   : my $xml = $obj->to_xml;
\& Function: Turns the invocant object into an XML string.
\& Returns : SCALAR
\& Args    : NONE
.Ve
.IP "\fIto_svg()\fR" 4
.IX Item "to_svg()"
Serializes invocant to \s-1SVG\s0.
.Sp
.Vb 8
\& Type    : Serializer
\& Title   : to_svg
\& Usage   : my $svg = $obj->to_svg;
\& Function: Turns the invocant object into an SVG string.
\& Returns : SCALAR
\& Args    : Same args as the Bio::Phylo::Treedrawer constructor
\& Notes   : This will only work if you have the SVG module
\&           from CPAN installed on your system.
.Ve
.IP "\fIto_dom()\fR" 4
.IX Item "to_dom()"
.Vb 7
\& Type    : Serializer
\& Title   : to_dom
\& Usage   : $tree->to_dom($dom)
\& Function: Generates a DOM subtree from the invocant
\&           and its contained objects
\& Returns : an Element object
\& Args    : DOM factory object
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Bio::Phylo::Listable" 4
.IX Item "Bio::Phylo::Listable"
The Bio::Phylo::Forest::Tree object inherits from
the Bio::Phylo::Listable object, so the methods defined
therein also apply to trees.
.IP "Bio::Phylo::Manual" 4
.IX Item "Bio::Phylo::Manual"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SH "REVISION"
.IX Header "REVISION"
.Vb 1
\& $Id: Tree.pm 1581 2010-12-14 20:35:50Z rvos $
.Ve
