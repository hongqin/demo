.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::NeXML::Meta 3"
.TH Bio::Phylo::NeXML::Meta 3 "2010-11-25" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Phylo::NeXML::Meta \- Single predicate/object annotation, attached to an
xml\-writable subject
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 14
\& use Bio::Phylo::Factory;
\& my $fac = Bio::Phylo::Factory->new;
\& my $url = 'http://purl.org/phylo/treebase/phylows/study/TB2:S1787';
\& my $proj = $fac->create_project->add_meta(
\&     $fac->create_meta(
\&         '-namespaces' => { 'cdao' => 'http://evolutionaryontology.org#' },
\&         '-triple'     => { 
\&             'cdao:hasMeta' => $fac->create_meta(
\&                 '-namespaces' => { 'cdao' => 'http://evolutionaryontology.org#' },
\&                 '-triple'     => { 'cdao:has_External_Reference' => $url }
\&             )
\&         }
\&     )
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
To comply with the NeXML standard (<http://www.nexml.org>), Bio::Phylo
implements metadata annotations which consist conceptually of \s-1RDF\s0 triples where
the subject is a container object that subclasses
Bio::Phylo::NeXML::Writable, and the predicate and object are defined in
this class. 
.PP
The objects of the triples provided by this class can be of any simple type
(string, number) or one of \s-1XML::DOM\s0, \s-1XML::GDOME\s0, XML::LibXML,
XML::Twig, \s-1XML::DOM2\s0, XML::DOMBacked, XML::Handler, XML::Element,
\&\s-1XML::API\s0, XML::Code or XML::XMLWriter or RDF::Core::Model.
.PP
When serialized, the Bio::Phylo::NeXML::Meta object in NeXML is typically written out
as an element called 'meta', with RDFa compliant attributes.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 12
\& Type    : Constructor
\& Title   : new
\& Usage   : my $anno = Bio::Phylo::NeXML::Meta->new;
\& Function: Initializes a Bio::Phylo::NeXML::Meta object.
\& Returns : A Bio::Phylo::NeXML::Meta object.
\& Args    : optional constructor arguments are key/value
\&                   pairs where the key corresponds with any of
\&                   the methods that starts with set_ (i.e. mutators) 
\&                   and the value is the permitted argument for such 
\&                   a method. The method name is changed such that,
\&                   in order to access the set_value($val) method
\&                   in the constructor, you would pass -value => $val
.Ve
.Sh "\s-1MUTATORS\s0"
.IX Subsection "MUTATORS"
.IP "\fIset_triple()\fR" 4
.IX Item "set_triple()"
Populates the triple, assuming that the invocant is attached to a subject.
.Sp
.Vb 12
\& Type    : Mutator
\& Title   : set_triple
\& Usage   : $meta->set_triple( $predicate, $object );
\& Function: Populates the triple.
\& Returns : Modified object.
\& Args    : $predicate - a CURIE whose namespace prefix must 
\&                        have been bound previously using 
\&                        $meta->set_namespaces( $prefix, $uri );
\&           $object    - any of the valid object types: a number,
\&                        a string, a url, a nested annotation
\&                        or anything that can be adapted by
\&                        Bio::Phylo::NeXML::Meta::XMLLiteral
.Ve
.Sh "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
.IP "\fIget_object()\fR" 4
.IX Item "get_object()"
Returns triple object
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_object
\& Usage   : my $val = $anno->get_object;
\& Function: Returns triple object
\& Returns : A triple object
\& Args    : NONE
.Ve
.IP "\fIget_predicate()\fR" 4
.IX Item "get_predicate()"
Returns triple predicate
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_predicate
\& Usage   : my $val = $anno->get_predicate;
\& Function: Returns triple predicate
\& Returns : A triple predicate
\& Args    : NONE
.Ve
.Sh "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\fIto_dom()\fR" 4
.IX Item "to_dom()"
.Vb 10
\& Type    : Serializer
\& Title   : to_dom
\& Usage   : $obj->to_dom
\& Function: Generates a DOM subtree from the invocant and
\&           its contained objects
\& Returns : a DOM element object (default: XML::Twig flavor)
\& Args    : DOM factory object
\& Note    : This is the generic function. It is redefined in the 
\&           classes below.
\&=cut
.Ve
.Sp
.Vb 18
\&    sub to_dom {
\&                my ($self, $dom) = @_;
\&                $dom ||= Bio::Phylo::NeXML::DOM->get_dom;
\&                if ( looks_like_object $dom, _DOMCREATOR_ ) {
\&                        my $elt = $self->get_dom_elt($dom);
\&                        if ( $self->can('get_entities') ) {
\&                                for my $ent ( @{ $self->get_entities } ) {
\&                                if ( looks_like_implementor $ent,'to_dom' ) { 
\&                                        $elt->set_child( $ent->to_dom($dom) );
\&                                }
\&                                }
\&                        }
\&                        return $elt;                
\&                }
\&                else {
\&                        throw 'BadArgs' => 'DOM factory object not provided';
\&                }       
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Bio::Phylo::Dictionary" 4
.IX Item "Bio::Phylo::Dictionary"
Annotation objects are combined into a dictionary.
.IP "Bio::Phylo::NeXML::Writable" 4
.IX Item "Bio::Phylo::NeXML::Writable"
This object inherits from Bio::Phylo::NeXML::Writable, so methods
defined there are also applicable here.
.IP "Bio::Phylo::Manual" 4
.IX Item "Bio::Phylo::Manual"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SH "REVISION"
.IX Header "REVISION"
.Vb 1
\& $Id: Meta.pm 1501 2010-11-16 19:47:42Z rvos $
.Ve
