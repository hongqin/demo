.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Matrices::Matrix 3"
.TH Bio::Phylo::Matrices::Matrix 3 "2010-12-08" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Phylo::Matrices::Matrix \- Character state matrix
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Bio::Phylo::Factory;
\& my $fac = Bio::Phylo::Factory->new;
.Ve
.PP
.Vb 5
\& # instantiate taxa object
\& my $taxa = $fac->create_taxa;
\& for ( 'Homo sapiens', 'Pan paniscus', 'Pan troglodytes' ) {
\&     $taxa->insert( $fac->create_taxon( '-name' => $_ ) );
\& }
.Ve
.PP
.Vb 19
\& # instantiate matrix object, 'standard' data type. All categorical
\& # data types follow semantics like this, though with different
\& # symbols in lookup table and matrix
\& my $standard_matrix = $fac->create_matrix(
\&     '-type'   => 'STANDARD',
\&     '-taxa'   => $taxa,
\&     '-lookup' => { 
\&         '-' => [],
\&         '0' => [ '0' ],
\&         '1' => [ '1' ],
\&         '?' => [ '0', '1' ],
\&     },
\&     '-labels' => [ 'Opposable big toes', 'Opposable thumbs', 'Not a pygmy' ],
\&     '-matrix' => [
\&         [ 'Homo sapiens'    => '0', '1', '1' ],
\&         [ 'Pan paniscus'    => '1', '1', '0' ],
\&         [ 'Pan troglodytes' => '1', '1', '1' ],
\&     ],
\& );
.Ve
.PP
.Vb 2
\& # note: complicated constructor for mixed data!
\& my $mixed_matrix = Bio::Phylo::Matrices::Matrix->new(
.Ve
.PP
.Vb 2
\&    # if you want to create 'mixed', value for '-type' is array ref...
\&    '-type' =>  [
.Ve
.PP
.Vb 2
\&        # ...with first field 'mixed'...                
\&        'mixed',
.Ve
.PP
.Vb 2
\&        # ...second field is an array ref...
\&        [
.Ve
.PP
.Vb 3
\&            # ...with _ordered_ key/value pairs...
\&            'dna'      => 10, # value is length of type range
\&            'standard' => 10, # value is length of type range
.Ve
.PP
.Vb 3
\&            # ... or, more complicated, value is a hash ref...
\&            'rna'      => {
\&                '-length' => 10, # value is length of type range
.Ve
.PP
.Vb 29
\&                # ...value for '-args' is an array ref with args 
\&                # as can be passed to 'unmixed' datatype constructors,
\&                # for example, here we modify the lookup table for
\&                # rna to allow both 'U' (default) and 'T'
\&                '-args'   => [
\&                    '-lookup' => {
\&                        'A' => [ 'A'                     ],
\&                        'C' => [ 'C'                     ],
\&                        'G' => [ 'G'                     ],
\&                        'U' => [ 'U'                     ],
\&                        'T' => [ 'T'                     ],
\&                        'M' => [ 'A', 'C'                ],
\&                        'R' => [ 'A', 'G'                ],
\&                        'S' => [ 'C', 'G'                ],
\&                        'W' => [ 'A', 'U', 'T'           ],
\&                        'Y' => [ 'C', 'U', 'T'           ],
\&                        'K' => [ 'G', 'U', 'T'           ],
\&                        'V' => [ 'A', 'C', 'G'           ],
\&                        'H' => [ 'A', 'C', 'U', 'T'      ],
\&                        'D' => [ 'A', 'G', 'U', 'T'      ],
\&                        'B' => [ 'C', 'G', 'U', 'T'      ],
\&                        'X' => [ 'G', 'A', 'U', 'T', 'C' ],
\&                        'N' => [ 'G', 'A', 'U', 'T', 'C' ],
\&                    },
\&                ],
\&            },
\&        ],
\&    ],
\& );
.Ve
.PP
.Vb 2
\& # prints 'mixed(Dna:1-10, Standard:11-20, Rna:21-30)'
\& print $mixed_matrix->get_type;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a container object that holds
Bio::Phylo::Matrices::Datum objects. The matrix
object inherits from Bio::Phylo::Listable, so the
methods defined there apply here.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "\fInew()\fR" 4
.IX Item "new()"
Matrix constructor.
.Sp
.Vb 9
\& Type    : Constructor
\& Title   : new
\& Usage   : my $matrix = Bio::Phylo::Matrices::Matrix->new;
\& Function: Instantiates a Bio::Phylo::Matrices::Matrix
\&           object.
\& Returns : A Bio::Phylo::Matrices::Matrix object.
\& Args    : -type   => optional, but if used must be FIRST argument, 
\&                      defines datatype, one of dna|rna|protein|
\&                      continuous|standard|restriction|[ mixed => [] ]
.Ve
.Sp
.Vb 5
\&           -taxa   => optional, link to taxa object
\&           -lookup => character state lookup hash ref
\&           -labels => array ref of character labels
\&           -matrix => two-dimensional array, first element of every
\&                      row is label, subsequent are characters
.Ve
.IP "\fInew_from_bioperl()\fR" 4
.IX Item "new_from_bioperl()"
Matrix constructor from Bio::Align::AlignI argument.
.Sp
.Vb 10
\& Type    : Constructor
\& Title   : new_from_bioperl
\& Usage   : my $matrix = 
\&           Bio::Phylo::Matrices::Matrix->new_from_bioperl(
\&               $aln           
\&           );
\& Function: Instantiates a 
\&           Bio::Phylo::Matrices::Matrix object.
\& Returns : A Bio::Phylo::Matrices::Matrix object.
\& Args    : An alignment that implements Bio::Align::AlignI
.Ve
.Sh "\s-1MUTATORS\s0"
.IX Subsection "MUTATORS"
.IP "set_special_symbols" 4
.IX Item "set_special_symbols"
Sets three special symbols in one call
.Sp
.Vb 16
\& Type    : Mutator
\& Title   : set_special_symbols
\& Usage   : $matrix->set_special_symbols( 
\&                       -missing   => '?', 
\&                       -gap       => '-', 
\&                       -matchchar => '.' 
\&                   );
\& Function: Assigns state labels.
\& Returns : $self
\& Args    : Three args (with distinct $x, $y and $z):
\&                       -missing   => $x, 
\&                       -gap       => $y, 
\&                       -matchchar => $z
\& Notes   : This method is here to ensure
\&           you don't accidentally use the
\&           same symbol for missing AND gap
.Ve
.IP "\fIset_statelabels()\fR" 4
.IX Item "set_statelabels()"
Sets argument state labels.
.Sp
.Vb 12
\& Type    : Mutator
\& Title   : set_statelabels
\& Usage   : $matrix->set_statelabels( [ [ 'state1', 'state2' ] ] );
\& Function: Assigns state labels.
\& Returns : $self
\& Args    : ARRAY, or nothing (to reset);
\&           The array is two-dimensional, 
\&           the first index is to indicate
\&           the column the labels apply to,
\&           the second dimension the states
\&           (sorted numerically or alphabetically,
\&           depending on what's appropriate)
.Ve
.IP "\fIset_charlabels()\fR" 4
.IX Item "set_charlabels()"
Sets argument character labels.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : set_charlabels
\& Usage   : $matrix->set_charlabels( [ 'char1', 'char2', 'char3' ] );
\& Function: Assigns character labels.
\& Returns : $self
\& Args    : ARRAY, or nothing (to reset);
.Ve
.IP "\fIset_gapmode()\fR" 4
.IX Item "set_gapmode()"
Defines matrix gapmode.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : set_gapmode
\& Usage   : $matrix->set_gapmode( 1 );
\& Function: Defines matrix gapmode ( false = missing, true = fifth state )
\& Returns : $self
\& Args    : boolean
.Ve
.IP "\fIset_matchchar()\fR" 4
.IX Item "set_matchchar()"
Assigns match symbol.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : set_matchchar
\& Usage   : $matrix->set_matchchar( $match );
\& Function: Assigns match symbol (default is '.').
\& Returns : $self
\& Args    : ARRAY
.Ve
.IP "\fIset_polymorphism()\fR" 4
.IX Item "set_polymorphism()"
Defines matrix 'polymorphism' interpretation.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : set_polymorphism
\& Usage   : $matrix->set_polymorphism( 1 );
\& Function: Defines matrix 'polymorphism' interpretation
\&           ( false = uncertainty, true = polymorphism )
\& Returns : $self
\& Args    : boolean
.Ve
.IP "\fIset_raw()\fR" 4
.IX Item "set_raw()"
Set contents using two-dimensional array argument.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : set_raw
\& Usage   : $matrix->set_raw( [ [ 'taxon1' => 'acgt' ], [ 'taxon2' => 'acgt' ] ] );
\& Function: Syntax sugar to define $matrix data contents.
\& Returns : $self
\& Args    : A two-dimensional array; first dimension contains matrix rows,
\&           second dimension contains taxon name / character string pair.
.Ve
.IP "\fIset_respectcase()\fR" 4
.IX Item "set_respectcase()"
Defines matrix case sensitivity interpretation.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : set_respectcase
\& Usage   : $matrix->set_respectcase( 1 );
\& Function: Defines matrix case sensitivity interpretation
\&           ( false = disregarded, true = "respectcase" )
\& Returns : $self
\& Args    : boolean
.Ve
.Sh "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
.IP "\fIget_special_symbols()\fR" 4
.IX Item "get_special_symbols()"
Retrieves hash ref for missing, gap and matchchar symbols
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_special_symbols
\& Usage   : my %syms = %{ $matrix->get_special_symbols };
\& Function: Retrieves special symbols
\& Returns : HASH ref, e.g. { -missing => '?', -gap => '-', -matchchar => '.' }
\& Args    : None.
.Ve
.IP "\fIget_statelabels()\fR" 4
.IX Item "get_statelabels()"
Retrieves state labels.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_statelabels
\& Usage   : my @statelabels = @{ $matrix->get_statelabels };
\& Function: Retrieves state labels.
\& Returns : ARRAY
\& Args    : None.
.Ve
.IP "\fIget_charlabels()\fR" 4
.IX Item "get_charlabels()"
Retrieves character labels.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_charlabels
\& Usage   : my @charlabels = @{ $matrix->get_charlabels };
\& Function: Retrieves character labels.
\& Returns : ARRAY
\& Args    : None.
.Ve
.IP "\fIget_gapmode()\fR" 4
.IX Item "get_gapmode()"
Returns matrix gapmode.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_gapmode
\& Usage   : do_something() if $matrix->get_gapmode;
\& Function: Returns matrix gapmode ( false = missing, true = fifth state )
\& Returns : boolean
\& Args    : none
.Ve
.IP "\fIget_matchchar()\fR" 4
.IX Item "get_matchchar()"
Returns matrix match character.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_matchchar
\& Usage   : my $char = $matrix->get_matchchar;
\& Function: Returns matrix match character (default is '.')
\& Returns : SCALAR
\& Args    : none
.Ve
.IP "\fIget_nchar()\fR" 4
.IX Item "get_nchar()"
Calculates number of characters.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_nchar
\& Usage   : my $nchar = $matrix->get_nchar;
\& Function: Calculates number of characters (columns) in matrix (if the matrix
\&           is non-rectangular, returns the length of the longest row).
\& Returns : INT
\& Args    : none
.Ve
.IP "\fIget_ntax()\fR" 4
.IX Item "get_ntax()"
Calculates number of taxa (rows) in matrix.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_ntax
\& Usage   : my $ntax = $matrix->get_ntax;
\& Function: Calculates number of taxa (rows) in matrix
\& Returns : INT
\& Args    : none
.Ve
.IP "\fIget_polymorphism()\fR" 4
.IX Item "get_polymorphism()"
Returns matrix 'polymorphism' interpretation.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_polymorphism
\& Usage   : do_something() if $matrix->get_polymorphism;
\& Function: Returns matrix 'polymorphism' interpretation
\&           ( false = uncertainty, true = polymorphism )
\& Returns : boolean
\& Args    : none
.Ve
.IP "\fIget_raw()\fR" 4
.IX Item "get_raw()"
Retrieves a 'raw' (two\-dimensional array) representation of the matrix's contents.
.Sp
.Vb 8
\& Type    : Accessor
\& Title   : get_raw
\& Usage   : my $rawmatrix = $matrix->get_raw;
\& Function: Retrieves a 'raw' (two-dimensional array) representation
\&           of the matrix's contents.
\& Returns : A two-dimensional array; first dimension contains matrix rows,
\&           second dimension contains taxon name and characters.
\& Args    : NONE
.Ve
.IP "\fIget_respectcase()\fR" 4
.IX Item "get_respectcase()"
Returns matrix case sensitivity interpretation.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_respectcase
\& Usage   : do_something() if $matrix->get_respectcase;
\& Function: Returns matrix case sensitivity interpretation
\&           ( false = disregarded, true = "respectcase" )
\& Returns : boolean
\& Args    : none
.Ve
.Sh "\s-1CALCULATIONS\s0"
.IX Subsection "CALCULATIONS"
.IP "\fIcalc_prop_invar()\fR" 4
.IX Item "calc_prop_invar()"
Calculates proportion of invariant sites.
.Sp
.Vb 12
\& Type    : Calculation
\& Title   : calc_prop_invar
\& Usage   : my $pinvar = $matrix->calc_prop_invar;
\& Function: Calculates proportion of invariant sites.
\& Returns : Scalar: a number
\& Args    : Optional:
\&           # if true, counts missing (usually the '?' symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           -missing => 1
\&           # if true, counts gaps (usually the '-' symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           -gap => 1
.Ve
.IP "\fIcalc_state_counts()\fR" 4
.IX Item "calc_state_counts()"
Calculates occurrences of states.
.Sp
.Vb 6
\& Type    : Calculation
\& Title   : calc_state_counts
\& Usage   : my %counts = %{ $matrix->calc_state_counts };
\& Function: Calculates occurrences of states.
\& Returns : Hashref: keys are states, values are counts
\& Args    : Optional - one or more states to focus on
.Ve
.IP "\fIcalc_state_frequencies()\fR" 4
.IX Item "calc_state_frequencies()"
Calculates the frequencies of the states observed in the matrix.
.Sp
.Vb 13
\& Type    : Calculation
\& Title   : calc_state_frequencies
\& Usage   : my %freq = %{ $object->calc_state_frequencies() };
\& Function: Calculates state frequencies
\& Returns : A hash, keys are state symbols, values are frequencies
\& Args    : Optional:
\&           # if true, counts missing (usually the '?' symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           -missing => 1
\&           # if true, counts gaps (usually the '-' symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           -gap => 1
\& Comments: Throws exception if matrix holds continuous values
.Ve
.IP "\fIcalc_distinct_site_patterns()\fR" 4
.IX Item "calc_distinct_site_patterns()"
Identifies the distinct distributions of states for all characters and
counts their occurrences. Returns an array\-of\-arrays, where the first cell
of each inner array holds the occurrence count, the second cell holds the
pattern, i.e. an array of states. For example, for a matrix like this:
.Sp
.Vb 7
\& taxon1 GTGTGTGTGTGTGTGTGTGTGTG
\& taxon2 AGAGAGAGAGAGAGAGAGAGAGA
\& taxon3 TCTCTCTCTCTCTCTCTCTCTCT
\& taxon4 TCTCTCTCTCTCTCTCTCTCTCT
\& taxon5 AAAAAAAAAAAAAAAAAAAAAAA
\& taxon6 CGCGCGCGCGCGCGCGCGCGCGC
\& taxon7 AAAAAAAAAAAAAAAAAAAAAAA
.Ve
.Sp
The following data structure will be returned:
.Sp
.Vb 4
\& [
\&        [ 12, [ 'G', 'A', 'T', 'T', 'A', 'C', 'A' ] ],
\&        [ 11, [ 'T', 'G', 'C', 'C', 'A', 'G', 'A' ] ]
\& ]
.Ve
.Sp
The patterns are sorted from most to least frequently occurring, the states
for each pattern are in the order of the rows in the matrix. (In other words,
the original matrix can more or less be reconstructed by inverting the patterns,
and multiplying them by their occurrence, although the order of the columns
will be lost.)
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_distinct_site_patterns
\& Usage   : my $patterns = $object->calc_distinct_site_patterns;
\& Function: Calculates distinct site patterns.
\& Returns : A multidimensional array, see above.
\& Args    : NONE
\& Comments:
.Ve
.IP "\fIcalc_gc_content()\fR" 4
.IX Item "calc_gc_content()"
Calculates the G+C content as a fraction on the total
.Sp
.Vb 15
\& Type    : Calculation
\& Title   : calc_gc_content
\& Usage   : my $fraction = $obj->calc_gc_content;
\& Function: Calculates G+C content
\& Returns : A number between 0 and 1 (inclusive)
\& Args    : Optional:
\&           # if true, counts missing (usually the '?' symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           -missing => 1
\&           # if true, counts gaps (usually the '-' symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           -gap => 1
\& Comments: Throws 'BadArgs' exception if matrix holds anything other than DNA
\&           or RNA. The calculation also takes the IUPAC symbol S (which is C|G)
\&           into account, but no other symbols (such as V, for A|C|G);
.Ve
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fIkeep_chars()\fR" 4
.IX Item "keep_chars()"
Creates a cloned matrix that only keeps the characters at 
the supplied (zero\-based) indices.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : keep_chars
\& Usage   : my $clone = $object->keep_chars([6,3,4,1]);
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : Required, an array ref of integers
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIprune_chars()\fR" 4
.IX Item "prune_chars()"
Creates a cloned matrix that omits the characters at 
the supplied (zero\-based) indices.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : prune_chars
\& Usage   : my $clone = $object->prune_chars([6,3,4,1]);
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : Required, an array ref of integers
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIbootstrap()\fR" 4
.IX Item "bootstrap()"
Creates bootstrapped clone.
.Sp
.Vb 17
\& Type    : Utility method
\& Title   : bootstrap
\& Usage   : my $bootstrap = $object->bootstrap;
\& Function: Creates bootstrapped clone.
\& Returns : A bootstrapped clone of the invocant.
\& Args    : Optional, a subroutine reference that returns a random
\&           integer between 0 (inclusive) and the argument provided
\&           to it (exclusive). The default implementation is to use
\&           sub { int( rand( shift ) ) }, a user might override this
\&           by providing an implementation with a better random number
\&           generator.
\& Comments: The bootstrapping algorithm uses perl's random number
\&           generator to create a new series of indices (without
\&           replacement) of the same length as the original matrix.
\&           These indices are first sorted, then applied to the 
\&           cloned sequences. Annotations (if present) stay connected
\&           to the resampled cells.
.Ve
.IP "\fIjackknife()\fR" 4
.IX Item "jackknife()"
Creates jackknifed clone.
.Sp
.Vb 18
\& Type    : Utility method
\& Title   : jackknife
\& Usage   : my $bootstrap = $object->jackknife(0.5);
\& Function: Creates jackknifed clone.
\& Returns : A jackknifed clone of the invocant.
\& Args    : * Required, a number between 0 and 1, representing the
\&             fraction of characters to jackknife. 
\&           * Optional, a subroutine reference that returns a random
\&             integer between 0 (inclusive) and the argument provided
\&             to it (exclusive). The default implementation is to use
\&             sub { int( rand( shift ) ) }, a user might override this
\&             by providing an implementation with a better random number
\&             generator.
\& Comments: The jackknife algorithm uses perl's random number
\&           generator to create a new series of indices of cells to keep.
\&           These indices are first sorted, then applied to the 
\&           cloned sequences. Annotations (if present) stay connected
\&           to the resampled cells.
.Ve
.IP "\fIclone()\fR" 4
.IX Item "clone()"
Clones invocant.
.Sp
.Vb 6
\& Type    : Utility method
\& Title   : clone
\& Usage   : my $clone = $object->clone;
\& Function: Creates a copy of the invocant object.
\& Returns : A copy of the invocant.
\& Args    : NONE
.Ve
.IP "\fIinsert()\fR" 4
.IX Item "insert()"
Insert argument in invocant.
.Sp
.Vb 8
\& Type    : Listable method
\& Title   : insert
\& Usage   : $matrix->insert($datum);
\& Function: Inserts $datum in $matrix.
\& Returns : Modified object
\& Args    : A datum object
\& Comments: This method re-implements the method by the same
\&           name in Bio::Phylo::Listable
.Ve
.IP "\fIvalidate()\fR" 4
.IX Item "validate()"
Validates the object's contents.
.Sp
.Vb 8
\& Type    : Method
\& Title   : validate
\& Usage   : $obj->validate
\& Function: Validates the object's contents
\& Returns : True or throws Bio::Phylo::Util::Exceptions::InvalidData
\& Args    : None
\& Comments: This method implements the interface method by the same
\&           name in Bio::Phylo::Matrices::TypeSafeData
.Ve
.IP "\fIcompress_lookup()\fR" 4
.IX Item "compress_lookup()"
Removes unused states from lookup table
.Sp
.Vb 6
\& Type    : Method
\& Title   : validate
\& Usage   : $obj->compress_lookup
\& Function: Removes unused states from lookup table
\& Returns : $self
\& Args    : None
.Ve
.IP "\fIcheck_taxa()\fR" 4
.IX Item "check_taxa()"
Validates taxa associations.
.Sp
.Vb 8
\& Type    : Method
\& Title   : check_taxa
\& Usage   : $obj->check_taxa
\& Function: Validates relation between matrix and taxa block 
\& Returns : Modified object
\& Args    : None
\& Comments: This method implements the interface method by the same
\&           name in Bio::Phylo::Taxa::TaxaLinker
.Ve
.IP "\fImake_taxa()\fR" 4
.IX Item "make_taxa()"
Creates a taxa block from the objects contents if none exists yet.
.Sp
.Vb 6
\& Type    : Method
\& Title   : make_taxa
\& Usage   : my $taxa = $obj->make_taxa
\& Function: Creates a taxa block from the objects contents if none exists yet.
\& Returns : $taxa
\& Args    : NONE
.Ve
.Sh "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\fIto_xml()\fR" 4
.IX Item "to_xml()"
Serializes matrix to nexml format.
.Sp
.Vb 7
\& Type    : Format convertor
\& Title   : to_xml
\& Usage   : my $data_block = $matrix->to_xml;
\& Function: Converts matrix object into a nexml element structure.
\& Returns : Nexml block (SCALAR).
\& Args    : Optional:
\&                   -compact => 1 (for compact representation of matrix)
.Ve
.IP "\fIto_nexus()\fR" 4
.IX Item "to_nexus()"
Serializes matrix to nexus format.
.Sp
.Vb 6
\& Type    : Format convertor
\& Title   : to_nexus
\& Usage   : my $data_block = $matrix->to_nexus;
\& Function: Converts matrix object into a nexus data block.
\& Returns : Nexus data block (SCALAR).
\& Args    : The following options are available:
.Ve
.Sp
.Vb 2
\&            # if set, writes TITLE & LINK tokens
\&            '-links' => 1
.Ve
.Sp
.Vb 3
\&            # if set, writes block as a "data" block (deprecated, but used by mrbayes),
\&            # otherwise writes "characters" block (default)
\&            -data_block => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes "RESPECTCASE" token
\&            -respectcase => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes "GAPMODE=(NEWSTATE or MISSING)" token
\&            -gapmode => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes "MSTAXA=(POLYMORPH or UNCERTAIN)" token
\&            -polymorphism => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes character labels
\&            -charlabels => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes state labels
\&            -statelabels => 1
.Ve
.Sp
.Vb 2
\&            # if set, writes mesquite-style charstatelabels
\&            -charstatelabels => 1
.Ve
.Sp
.Vb 5
\&            # by default, names for sequences are derived from $datum->get_name, if 
\&            # 'internal' is specified, uses $datum->get_internal_name, if 'taxon'
\&            # uses $datum->get_taxon->get_name, if 'taxon_internal' uses 
\&            # $datum->get_taxon->get_internal_name, if $key, uses $datum->get_generic($key)
\&            -seqnames => one of (internal|taxon|taxon_internal|$key)
.Ve
.IP "\fIto_dom()\fR" 4
.IX Item "to_dom()"
Analog to to_xml.
.Sp
.Vb 9
\& Type    : Serializer
\& Title   : to_dom
\& Usage   : $matrix->to_dom
\& Function: Generates a DOM subtree from the invocant
\&           and its contained objects
\& Returns : an Element object
\& Args    : Optional:
\&           -compact => 1 : renders characters as sequences,
\&                           not individual cells
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Bio::Phylo::Taxa::TaxaLinker" 4
.IX Item "Bio::Phylo::Taxa::TaxaLinker"
This object inherits from Bio::Phylo::Taxa::TaxaLinker, so the
methods defined therein are also applicable to Bio::Phylo::Matrices::Matrix
objects.
.IP "Bio::Phylo::Matrices::TypeSafeData" 4
.IX Item "Bio::Phylo::Matrices::TypeSafeData"
This object inherits from Bio::Phylo::Matrices::TypeSafeData, so the
methods defined therein are also applicable to Bio::Phylo::Matrices::Matrix
objects.
.IP "Bio::Phylo::Manual" 4
.IX Item "Bio::Phylo::Manual"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SH "REVISION"
.IX Header "REVISION"
.Vb 1
\& $Id: Matrix.pm 1569 2010-12-09 03:13:37Z rvos $
.Ve
