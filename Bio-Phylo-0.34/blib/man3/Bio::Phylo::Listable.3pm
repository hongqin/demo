.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Listable 3"
.TH Bio::Phylo::Listable 3 "2010-11-17" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Phylo::Listable \- List of things, super class for many objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& No direct usage, parent class. Methods documented here 
\& are available for all objects that inherit from it.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A listable object is an object that contains multiple smaller objects of the
same type. For example: a tree contains nodes, so it's a listable object.
.PP
This class contains methods that are useful for all listable objects: Matrices
(i.e. sets of matrix objects), individual Matrix objects, Datum objects (i.e.
character state sequences), Taxa, Forest, Tree and Node objects.
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "\fInew()\fR" 4
.IX Item "new()"
Listable object constructor.
.Sp
.Vb 6
\& Type    : Constructor
\& Title   : new
\& Usage   : my $obj = Bio::Phylo::Listable->new;
\& Function: Instantiates a Bio::Phylo::Listable object
\& Returns : A Bio::Phylo::Listable object.
\& Args    : none
.Ve
.Sh "\s-1ARRAY\s0 \s-1METHODS\s0"
.IX Subsection "ARRAY METHODS"
.IP "\fIinsert()\fR" 4
.IX Item "insert()"
Pushes an object into its container.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : insert
\& Usage   : $obj->insert($other_obj);
\& Function: Pushes an object into its container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
.Ve
.IP "\fIinsert_at_index()\fR" 4
.IX Item "insert_at_index()"
Inserts argument object in container at argument index.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : insert_at_index
\& Usage   : $obj->insert_at_index($other_obj, $i);
\& Function: Inserts $other_obj at index $i in container $obj
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
.Ve
.IP "\fIdelete()\fR" 4
.IX Item "delete()"
Deletes argument from container.
.Sp
.Vb 18
\& Type    : Mutator
\& Title   : delete
\& Usage   : $obj->delete($other_obj);
\& Function: Deletes an object from its container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
\& Note    : Be careful with this method: deleting 
\&           a node from a tree like this will 
\&           result in undefined references in its 
\&           neighbouring nodes. Its children will 
\&           have their parent reference become 
\&           undef (instead of pointing to their 
\&           grandparent, as collapsing a node would 
\&           do). The same is true for taxon objects 
\&           that reference datum objects: if the 
\&           datum object is deleted from a matrix 
\&           (say), the taxon will now hold undefined 
\&           references.
.Ve
.IP "\fIclear()\fR" 4
.IX Item "clear()"
Empties container object.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : clear
\& Usage   : $obj->clear();
\& Function: Clears the container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : Note.
\& Note    :
.Ve
.IP "\fIprune_entities()\fR" 4
.IX Item "prune_entities()"
Prunes the container's contents specified by an array reference of indices.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : prune_entities
\& Usage   : $list->keep_entities([9,7,7,6]);
\& Function: Prunes a subset of contents
\& Returns : A Bio::Phylo::Listable object.
\& Args    : An array reference of indices
.Ve
.IP "\fIkeep_entities()\fR" 4
.IX Item "keep_entities()"
Keeps the container's contents specified by an array reference of indices.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : keep_entities
\& Usage   : $list->keep_entities([9,7,7,6]);
\& Function: Keeps a subset of contents
\& Returns : A Bio::Phylo::Listable object.
\& Args    : An array reference of indices
.Ve
.IP "\fIget_entities()\fR" 4
.IX Item "get_entities()"
Returns a reference to an array of objects contained by the listable object.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_entities
\& Usage   : my @entities = @{ $obj->get_entities };
\& Function: Retrieves all entities in the container.
\& Returns : A reference to a list of Bio::Phylo::* 
\&           objects.
\& Args    : none.
.Ve
.IP "\fIget_index_of()\fR" 4
.IX Item "get_index_of()"
Returns the index of the argument in the list,
or undef if the list doesn't contain the argument
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_index_of
\& Usage   : my $i = $listable->get_index_of($obj)
\& Function: Returns the index of the argument in the list,
\&           or undef if the list doesn't contain the argument
\& Returns : An index or undef
\& Args    : A contained object
.Ve
.IP "\fIget_by_index()\fR" 4
.IX Item "get_by_index()"
Gets element at index from container.
.Sp
.Vb 14
\& Type    : Accessor
\& Title   : get_by_index
\& Usage   : my $contained_obj = $obj->get_by_index($i);
\& Function: Retrieves the i'th entity 
\&           from a listable object.
\& Returns : An entity stored by a listable 
\&           object (or array ref for slices).
\& Args    : An index or range. This works 
\&           the way you dereference any perl
\&           array including through slices, 
\&           i.e. $obj->get_by_index(0 .. 10)>
\&           $obj->get_by_index(0, -1) 
\&           and so on.
\& Comments: Throws if out-of-bounds
.Ve
.IP "\fIget_by_regular_expression()\fR" 4
.IX Item "get_by_regular_expression()"
Gets elements that match regular expression from container.
.Sp
.Vb 16
\& Type    : Accessor
\& Title   : get_by_regular_expression
\& Usage   : my @objects = @{ 
\&               $obj->get_by_regular_expression(
\&                    -value => $method,
\&                    -match => $re
\&            ) };
\& Function: Retrieves the data in the 
\&           current Bio::Phylo::Listable 
\&           object whose $method output 
\&           matches $re
\& Returns : A list of Bio::Phylo::* objects.
\& Args    : -value => any of the string 
\&                     datum props (e.g. 'get_type')
\&           -match => a compiled regular 
\&                     expression (e.g. qr/^[D|R]NA$/)
.Ve
.IP "\fIget_by_value()\fR" 4
.IX Item "get_by_value()"
Gets elements that meet numerical rule from container.
.Sp
.Vb 22
\& Type    : Accessor
\& Title   : get_by_value
\& Usage   : my @objects = @{ $obj->get_by_value(
\&              -value => $method,
\&              -ge    => $number
\&           ) };
\& Function: Iterates through all objects 
\&           contained by $obj and returns 
\&           those for which the output of 
\&           $method (e.g. get_tree_length) 
\&           is less than (-lt), less than 
\&           or equal to (-le), equal to 
\&           (-eq), greater than or equal to 
\&           (-ge), or greater than (-gt) $number.
\& Returns : A reference to an array of objects
\& Args    : -value => any of the numerical 
\&                     obj data (e.g. tree length)
\&           -lt    => less than
\&           -le    => less than or equals
\&           -eq    => equals
\&           -ge    => greater than or equals
\&           -gt    => greater than
.Ve
.IP "\fIget_by_name()\fR" 4
.IX Item "get_by_name()"
Gets first element that has argument name
.Sp
.Vb 8
\& Type    : Accessor
\& Title   : get_by_name
\& Usage   : my $found = $obj->get_by_name('foo');
\& Function: Retrieves the first contained object
\&           in the current Bio::Phylo::Listable 
\&           object whose name is 'foo'
\& Returns : A Bio::Phylo::* object.
\& Args    : A name (string)
.Ve
.Sh "\s-1ITERATOR\s0 \s-1METHODS\s0"
.IX Subsection "ITERATOR METHODS"
.IP "\fIfirst()\fR" 4
.IX Item "first()"
Jumps to the first element contained by the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : first
\& Usage   : my $first_obj = $obj->first;
\& Function: Retrieves the first 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIlast()\fR" 4
.IX Item "last()"
Jumps to the last element contained by the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : last
\& Usage   : my $last_obj = $obj->last;
\& Function: Retrieves the last 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIcurrent()\fR" 4
.IX Item "current()"
Returns the current focal element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : current
\& Usage   : my $current_obj = $obj->current;
\& Function: Retrieves the current focal 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fInext()\fR" 4
.IX Item "next()"
Returns the next focal element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : next
\& Usage   : my $next_obj = $obj->next;
\& Function: Retrieves the next focal 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIprevious()\fR" 4
.IX Item "previous()"
Returns the previous element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : previous
\& Usage   : my $previous_obj = $obj->previous;
\& Function: Retrieves the previous 
\&           focal entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIcurrent_index()\fR" 4
.IX Item "current_index()"
Returns the current internal index of the container.
.Sp
.Vb 7
\& Type    : Generic query
\& Title   : current_index
\& Usage   : my $last_index = $obj->current_index;
\& Function: Returns the current internal 
\&           index of the container.
\& Returns : An integer
\& Args    : none.
.Ve
.IP "\fIlast_index()\fR" 4
.IX Item "last_index()"
Returns the highest valid index of the container.
.Sp
.Vb 7
\& Type    : Generic query
\& Title   : last_index
\& Usage   : my $last_index = $obj->last_index;
\& Function: Returns the highest valid 
\&           index of the container.
\& Returns : An integer
\& Args    : none.
.Ve
.Sh "\s-1VISITOR\s0 \s-1METHODS\s0"
.IX Subsection "VISITOR METHODS"
.IP "\fIvisit()\fR" 4
.IX Item "visit()"
Iterates over objects contained by container, executes argument
code reference on each.
.Sp
.Vb 9
\& Type    : Visitor predicate
\& Title   : visit
\& Usage   : $obj->visit( 
\&               sub{ print $_[0]->get_name, "\en" } 
\&           );
\& Function: Implements visitor pattern 
\&           using code reference.
\& Returns : The container, possibly modified.
\& Args    : a CODE reference.
.Ve
.Sh "\s-1TESTS\s0"
.IX Subsection "TESTS"
.IP "\fIcontains()\fR" 4
.IX Item "contains()"
Tests whether the container object contains the argument object.
.Sp
.Vb 9
\& Type    : Test
\& Title   : contains
\& Usage   : if ( $obj->contains( $other_obj ) ) {
\&               # do something
\&           }
\& Function: Tests whether the container object 
\&           contains the argument object
\& Returns : BOOLEAN
\& Args    : A Bio::Phylo::* object
.Ve
.IP "\fIcan_contain()\fR" 4
.IX Item "can_contain()"
Tests if argument can be inserted in container.
.Sp
.Vb 6
\& Type    : Test
\& Title   : can_contain
\& Usage   : &do_something if $listable->can_contain( $obj );
\& Function: Tests if $obj can be inserted in $listable
\& Returns : BOOL
\& Args    : An $obj to test
.Ve
.Sh "\s-1UTILITY\s0 \s-1METHODS\s0"
.IX Subsection "UTILITY METHODS"
.IP "\fIset_listener()\fR" 4
.IX Item "set_listener()"
Attaches a listener (code ref) which is executed when contents change.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : set_listener
\& Usage   : $object->set_listener( sub { my $object = shift; } );
\& Function: Attaches a listener (code ref) which is executed when contents change.
\& Returns : Invocant.
\& Args    : A code reference.
\& Comments: When executed, the code reference will receive $object
\&           (the container) as its first argument.
.Ve
.IP "\fInotify_listeners()\fR" 4
.IX Item "notify_listeners()"
Notifies listeners of changed contents.
.Sp
.Vb 7
\& Type    : Utility method
\& Title   : notify_listeners
\& Usage   : $object->notify_listeners;
\& Function: Notifies listeners of changed contents.
\& Returns : Invocant.
\& Args    : NONE.
\& Comments:
.Ve
.IP "\fIclone()\fR" 4
.IX Item "clone()"
Clones container.
.Sp
.Vb 7
\& Type    : Utility method
\& Title   : clone
\& Usage   : my $clone = $object->clone;
\& Function: Creates a deep copy of the container.
\& Returns : A copy of the container.
\& Args    : NONE.
\& Comments: Cloning is currently experimental, use with caution.
.Ve
.IP "\fIcross_reference()\fR" 4
.IX Item "cross_reference()"
The cross_reference method links node and datum objects to the taxa they apply
to. After crossreferencing a matrix with a taxa object, every datum object has
a reference to a taxon object stored in its \f(CW\*(C`$datum\->get_taxon\*(C'\fR field, and
every taxon object has a list of references to datum objects stored in its
\&\f(CW\*(C`$taxon\->get_data\*(C'\fR field.
.Sp
.Vb 9
\& Type    : Generic method
\& Title   : cross_reference
\& Usage   : $obj->cross_reference($taxa);
\& Function: Crossreferences the entities 
\&           in the container with names 
\&           in $taxa
\& Returns : string
\& Args    : A Bio::Phylo::Taxa object
\& Comments:
.Ve
.Sh "\s-1SETS\s0 \s-1MANAGEMENT\s0"
.IX Subsection "SETS MANAGEMENT"
Many Bio::Phylo objects are segmented, i.e. they contain one or more subparts 
of the same type. For example, a matrix contains multiple rows; each row 
contains multiple cells; a tree contains nodes, and so on. (Segmented objects
all inherit from Bio::Phylo::Listable, i.e. the class whose documentation you're
reading here.) In many cases it is useful to be able to define subsets of the 
contents of segmented objects, for example sets of taxon objects inside a taxa 
block. The Bio::Phylo::Listable object allows this through a number of methods 
(add_set, remove_set, add_to_set, remove_from_set etc.). Those methods delegate 
the actual management of the set contents to the Bio::Phylo::Set object. 
Consult the documentation for Bio::Phylo::Set for a code sample.
.IP "\fIadd_set()\fR" 4
.IX Item "add_set()"
.Vb 6
\& Type    : Mutator
\& Title   : add_set
\& Usage   : $obj->add_set($set)
\& Function: Associates a Bio::Phylo::Set object with the container
\& Returns : Invocant
\& Args    : A Bio::Phylo::Set object
.Ve
.IP "\fIremove_set()\fR" 4
.IX Item "remove_set()"
.Vb 6
\& Type    : Mutator
\& Title   : remove_set
\& Usage   : $obj->remove_set($set)
\& Function: Removes association between a Bio::Phylo::Set object and the container
\& Returns : Invocant
\& Args    : A Bio::Phylo::Set object
.Ve
.IP "\fIget_sets()\fR" 4
.IX Item "get_sets()"
.Vb 6
\& Type    : Accessor
\& Title   : get_sets
\& Usage   : my @sets = @{ $obj->get_sets() };
\& Function: Retrieves all associated Bio::Phylo::Set objects
\& Returns : Invocant
\& Args    : None
.Ve
.IP "\fIis_in_set()\fR" 4
.IX Item "is_in_set()"
.Vb 13
\& Type    : Test
\& Title   : is_in_set
\& Usage   : @do_something if $listable->is_in_set($obj,$set);
\& Function: Returns whether or not the first argument is listed in the second argument
\& Returns : Boolean
\& Args    : $obj - an object that may, or may not be in $set
\&           $set - the Bio::Phylo::Set object to query
\& Notes   : This method makes two assumptions:
\&           i) the $set object is associated with the container,
\&              i.e. add_set($set) has been called previously
\&           ii) the $obj object is part of the container
\&           If either assumption is violated a warning message
\&           is printed.
.Ve
.IP "\fIadd_to_set()\fR" 4
.IX Item "add_to_set()"
.Vb 10
\& Type    : Mutator
\& Title   : add_to_set
\& Usage   : $listable->add_to_set($obj,$set);
\& Function: Adds first argument to the second argument
\& Returns : Invocant
\& Args    : $obj - an object to add to $set
\&           $set - the Bio::Phylo::Set object to add to
\& Notes   : this method assumes that $obj is already 
\&           part of the container. If that assumption is
\&           violated a warning message is printed.
.Ve
.IP "\fIremove_from_set()\fR" 4
.IX Item "remove_from_set()"
.Vb 10
\& Type    : Mutator
\& Title   : remove_from_set
\& Usage   : $listable->remove_from_set($obj,$set);
\& Function: Removes first argument from the second argument
\& Returns : Invocant
\& Args    : $obj - an object to remove from $set
\&           $set - the Bio::Phylo::Set object to remove from
\& Notes   : this method assumes that $obj is already 
\&           part of the container. If that assumption is
\&           violated a warning message is printed.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.Sh "Objects inheriting from Bio::Phylo::Listable"
.IX Subsection "Objects inheriting from Bio::Phylo::Listable"
.IP "Bio::Phylo::Forest" 4
.IX Item "Bio::Phylo::Forest"
Iterate over a set of trees.
.IP "Bio::Phylo::Forest::Tree" 4
.IX Item "Bio::Phylo::Forest::Tree"
Iterate over nodes in a tree.
.IP "Bio::Phylo::Forest::Node" 4
.IX Item "Bio::Phylo::Forest::Node"
Iterate of children of a node.
.IP "Bio::Phylo::Matrices" 4
.IX Item "Bio::Phylo::Matrices"
Iterate over a set of matrices.
.IP "Bio::Phylo::Matrices::Matrix" 4
.IX Item "Bio::Phylo::Matrices::Matrix"
Iterate over the datum objects in a matrix.
.IP "Bio::Phylo::Matrices::Datum" 4
.IX Item "Bio::Phylo::Matrices::Datum"
Iterate over the characters in a datum.
.IP "Bio::Phylo::Taxa" 4
.IX Item "Bio::Phylo::Taxa"
Iterate over a set of taxa.
.Sh "Superclasses"
.IX Subsection "Superclasses"
.IP "Bio::Phylo::NeXML::Writable" 4
.IX Item "Bio::Phylo::NeXML::Writable"
This object inherits from Bio::Phylo::NeXML::Writable, so methods
defined there are also applicable here.
.SH "REVISION"
.IX Header "REVISION"
.Vb 1
\& $Id: Listable.pm 1512 2010-11-16 23:45:05Z rvos $
.Ve
